"""
MarkPigeon GitHub Publisher Module

Handles uploading HTML files and assets to GitHub with GitHub Pages support.
"""

import logging
import time
from collections.abc import Callable
from dataclasses import dataclass, field
from pathlib import Path

from github import Github, GithubException
from github.Repository import Repository

logger = logging.getLogger(__name__)

# MarkPigeon repository for starring
MARKPIGEON_REPO = "steven-jianhao-li/MarkPigeon"


@dataclass
class PublishResult:
    """Result of publishing operation."""

    success: bool = False
    url: str = ""
    message: str = ""
    files_uploaded: list[str] = field(default_factory=list)
    errors: list[str] = field(default_factory=list)


class PublishError(Exception):
    """Exception raised during publishing."""

    pass


class GitHubPublisher:
    """
    Handles GitHub publishing operations.

    Features:
    - Token validation
    - Repository creation with GitHub Pages
    - File upload with conflict handling
    - Progress callbacks
    """

    def __init__(
        self,
        token: str,
        repo_name: str = "markpigeon-shelf",
        progress_callback: Callable[[int, int, str], None] | None = None,
    ):
        """
        Initialize the publisher.

        Args:
            token: GitHub Personal Access Token
            repo_name: Target repository name
            progress_callback: Optional callback for progress updates (current, total, message)
        """
        self.token = token
        self.repo_name = repo_name
        self.progress_callback = progress_callback
        self._github: Github | None = None
        self._user = None
        self._repo: Repository | None = None

    def _report_progress(self, current: int, total: int, message: str) -> None:
        """Report progress to callback if set."""
        if self.progress_callback:
            self.progress_callback(current, total, message)

    def check_connection(self) -> tuple[bool, str]:
        """
        Validate token and get user info.

        Returns:
            Tuple of (success, username or error message)
        """
        try:
            self._github = Github(self.token)
            self._user = self._github.get_user()
            username = self._user.login
            logger.info(f"Successfully authenticated as: {username}")
            return True, username
        except GithubException as e:
            error_msg = f"Authentication failed: {e.data.get('message', str(e))}"
            logger.error(error_msg)
            return False, error_msg
        except Exception as e:
            error_msg = f"Connection error: {str(e)}"
            logger.error(error_msg)
            return False, error_msg

    def get_or_create_repo(self) -> Repository:
        """
        Get existing repo or create a new one.

        Returns:
            Repository object

        Raises:
            PublishError: If repo creation fails
        """
        if not self._github or not self._user:
            raise PublishError("Not authenticated. Call check_connection first.")

        try:
            # Try to get existing repo
            repo = self._user.get_repo(self.repo_name)
            logger.info(f"Found existing repo: {repo.full_name}")
            return repo
        except GithubException as e:
            if e.status != 404:
                raise PublishError(f"Failed to access repo: {e.data.get('message', str(e))}")

        # Create new repo
        try:
            repo = self._user.create_repo(
                name=self.repo_name,
                description="ðŸ“„ My MarkPigeon document shelf - HTML pages generated by [MarkPigeon](https://github.com/steven-jianhao-li/MarkPigeon)",
                homepage=f"https://{self._user.login}.github.io/{self.repo_name}/",
                private=False,  # Must be public for free GitHub Pages
                has_issues=False,
                has_wiki=False,
                auto_init=True,  # Create with README
            )
            logger.info(f"Created new repo: {repo.full_name}")

            # Wait a moment for repo initialization
            time.sleep(2)

            return repo
        except GithubException as e:
            raise PublishError(f"Failed to create repo: {e.data.get('message', str(e))}")

    def enable_pages(self, repo: Repository) -> bool:
        """
        Enable GitHub Pages for the repository.

        Args:
            repo: Repository object

        Returns:
            True if successful
        """
        try:
            # Try to enable Pages via raw API
            # PyGithub doesn't have full Pages API support
            try:
                repo._requester.requestJsonAndCheck(
                    "POST",
                    f"/repos/{repo.full_name}/pages",
                    input={"source": {"branch": "main", "path": "/"}},
                )
                logger.info("GitHub Pages enabled successfully")
                return True
            except GithubException as e:
                # Check if Pages is already enabled (409 Conflict)
                if e.status == 409:
                    logger.info("GitHub Pages already enabled")
                    return True
                raise
        except GithubException as e:
            # Pages might require manual setup for some accounts
            logger.warning(f"Could not enable Pages programmatically: {e}")
            return False
        except Exception as e:
            logger.warning(f"Pages setup error: {e}")
            return False

    def upload_file(
        self,
        repo: Repository,
        file_path: Path,
        repo_path: str,
        commit_message: str = "Update via MarkPigeon",
    ) -> bool:
        """
        Upload a single file to the repository.

        Args:
            repo: Repository object
            file_path: Local file path
            repo_path: Path in repository
            commit_message: Commit message

        Returns:
            True if successful
        """
        try:
            # Read file content
            content = file_path.read_bytes()

            # Check if file exists (for update)
            try:
                existing = repo.get_contents(repo_path)
                sha = existing.sha
                repo.update_file(
                    path=repo_path,
                    message=commit_message,
                    content=content,
                    sha=sha,
                )
                logger.debug(f"Updated file: {repo_path}")
            except GithubException:
                # File doesn't exist, create it
                repo.create_file(
                    path=repo_path,
                    message=commit_message,
                    content=content,
                )
                logger.debug(f"Created file: {repo_path}")

            return True
        except Exception as e:
            logger.error(f"Failed to upload {file_path}: {e}")
            return False

    def publish(
        self,
        html_path: Path,
        assets_dir: Path | None = None,
    ) -> PublishResult:
        """
        Publish HTML file and assets to GitHub.

        Args:
            html_path: Path to HTML file
            assets_dir: Optional path to assets directory

        Returns:
            PublishResult with URL and status
        """
        result = PublishResult()

        # Step 1: Validate connection
        self._report_progress(0, 100, "Connecting to GitHub...")
        success, msg = self.check_connection()
        if not success:
            result.message = msg
            result.errors.append(msg)
            return result

        username = msg

        # Step 2: Get or create repo
        self._report_progress(10, 100, "Preparing repository...")
        try:
            self._repo = self.get_or_create_repo()
        except PublishError as e:
            result.message = str(e)
            result.errors.append(str(e))
            return result

        # Step 3: Enable Pages
        self._report_progress(20, 100, "Configuring GitHub Pages...")
        self.enable_pages(self._repo)

        # Step 4: Collect files to upload
        files_to_upload: list[tuple[Path, str]] = []

        # Add HTML file
        html_name = html_path.name
        files_to_upload.append((html_path, html_name))

        # Add assets
        if assets_dir and assets_dir.exists():
            assets_dir_name = assets_dir.name
            for asset_file in assets_dir.iterdir():
                if asset_file.is_file():
                    repo_path = f"{assets_dir_name}/{asset_file.name}"
                    files_to_upload.append((asset_file, repo_path))

        # Step 5: Upload files
        total_files = len(files_to_upload)
        for i, (file_path, repo_path) in enumerate(files_to_upload):
            progress = 30 + int((i / total_files) * 60)
            self._report_progress(progress, 100, f"Uploading {file_path.name}...")

            if self.upload_file(self._repo, file_path, repo_path):
                result.files_uploaded.append(repo_path)
            else:
                result.errors.append(f"Failed to upload: {repo_path}")

        # Step 6: Build result
        self._report_progress(95, 100, "Finalizing...")

        if result.files_uploaded:
            result.success = True
            result.url = f"https://{username}.github.io/{self.repo_name}/{html_name}"
            result.message = (
                f"Published successfully! {len(result.files_uploaded)} file(s) uploaded."
            )
        else:
            result.message = "No files were uploaded."

        self._report_progress(100, 100, "Done!")
        return result

    def star_repo(self, repo_full_name: str = MARKPIGEON_REPO) -> tuple[bool, str]:
        """
        Star a repository.

        Args:
            repo_full_name: Full repository name (owner/repo)

        Returns:
            Tuple of (success, message)
        """
        if not self._github:
            success, msg = self.check_connection()
            if not success:
                return False, msg

        try:
            repo = self._github.get_repo(repo_full_name)
            self._github.get_user().add_to_starred(repo)
            return True, f"â­ Thank you for starring {repo_full_name}!"
        except GithubException as e:
            if "already starred" in str(e).lower() or e.status == 304:
                return True, "You've already starred this repo. Thank you! ðŸ’–"
            return False, f"Could not star repo: {e.data.get('message', str(e))}"
        except Exception as e:
            return False, f"Error: {str(e)}"

    def check_starred(self, repo_full_name: str = MARKPIGEON_REPO) -> bool:
        """Check if user has starred the repo."""
        if not self._github:
            return False

        try:
            repo = self._github.get_repo(repo_full_name)
            return self._github.get_user().has_in_starred(repo)
        except Exception:
            return False
